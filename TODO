/**
@page todolist Project to-do list


LHAPDF6 TODO list
=================


FOR BETA 3 / RELEASE CANDIDATE
------------------------------

- **Uncontrolled bulk PDF migration (AB)**

   Just migrate lots of major sets without explicit quality checking. It's a
   beta, live with it... Include:
     CT10, CT10nlo, CT10nnlo
     HERAPDF15NNLO_EIG, HERAPDF15NNLO_VAR
     HERAPDF15NLO_EIG, HERAPDF15NLO_VAR
     MSTW2008lo68cl, MSTW2008lo90cl
     MSTW2008nlo68cl, MSTW2008nlo90cl
     MSTW2008nnlo68cl, MSTW2008nnlo90cl
     MRSTMCal, MRST2007lomod
     NNPDF23_nlo_as_0114 .. 0124
     NNPDF23_nnlo_as_0114 .. 0124


FOR STABLE 6.0.0 RELEASE
------------------------

- **Complete and test AlphaS system (MR,KN)**

   Use doubled Q values to implement 1D subgrids.

   Need to respect FFNS/VFNS flags.

   Include alpha_s raw and deviation plotting in the migration dump/comparison scripts.

- **Non-visual PDF validation (AB)**

   More automation of validation is required... we can't check thousands of
   plots so need a more compact performance metric for printout in the event of
   comparison failure. Needs to be silent 99% of the time.

- **MSTW2008 PDF migration (GW,AB)**

   First attempt to use subgrids in anger. Also subgrid in alpha_s.

   Check why MSTW2008NNLO interpolation goes so wild at low Q:
   Related to the eps = 10^-6 GeV treatment combined with value discontinuity at
   Q = m_c => ~infinite gradient term entering the interpolation? Fix with
   subgrids? Epsilon separations can't be allowed in LHAPDF: subgrids should be
   absolutely contiguous.

- **NNPDF2.3 PDF migration (AB)**

   Includes non-zero top PDFs? Still many >> 1e-3 deviations. Why do -1, -2 PDFs
   look valence-like?

- **Improve CTEQ6L1 grid efficiency if possible (MR)**

- **Write-up**

   Target at EPJC Tools or CPC? Can put on arXiv before October, but delay
   publication submission to aim (hope) for for eligibility in *next* REF.

- **Print out banner info?... needed by code that greps for it :-/**

   e.g. ATLAS' Generate_trf.py. Implement the Fortran getdescription_() and
   require it to be explicitly called? Or automatically call it from the Fortran
   interface only. *Or provide a C++ function to return the current PDF identity
   and call that explicitly.*

- **Bundle Cython generated files if possible so Cython isn't needed for a tarball build**

   If possible. I think this is actually important: every dependency will put
   off a large fraction of potential users. Although, cf. Rivet, a pre-supplied
   build will be important for reducing that social/technical problem.

- **Add Info/Config mappings to Cython (AB)**


AS AND WHEN
-----------

- **Add AlphaS mappings to Cython (AB)**

- **Expose LHAGLUE slots system for C++ use**

   Automatic memory management can be nice for everyone.

- **MRST2004qed migration**

- **Support photon structure functions**

   Need to make use of the P2 and IP2 params. No idea how to even start here...

- **Support nuclear corrections**

   Have to be applyable to all nucleon PDFs, regardless of implementation:
   probably nuclear PDFs will inherit from PDF (since they are PDFs) and
   _contain_ a nucleon PDF whose values will be modified before returning.

- **Improved x -> 1 (and Q -> 0?) evolution (GW,...)**

   Graeme, etc.: x -> 1 extrapolation should be done carefully to ensure that
   all PDFs -> 0 at x = 1.0, (usually) without going negative. This probably
   deserves specialisation beyond generic splines. Graeme will look at what's
   done in the CTEQ code (other than interpolating in x**0.3)

- **Try using boost::function to generically modify the interpolation measures in x, Q (AB)**

- **Use Autoconf's more robust FC_* Fortran function name macros?**

   This would require testing for a Fortran compiler, which we would rather not
   do... Test for a Fortran compiler unless told not to build LHAGLUE?

- **Separate the x and Q2 inter/extrapolation?**

   Allow mix & match combinations. Would this simplify the code since the
   1D interpolation methods are very simple and the 2D is built from them?

- **Allow use of valence/sea etc. decompositions**

   GridPDF may be inherited from to allow the returned values to be built from
   separate interpolations of component PDFs such as interpolated valence, sea,
   or difference PDFs that are combined to make the physical ones. The PDG ID
   code range for "generator specific" applications may be used, but we'll need
   to bear in mind that this will mean that the flavor ID list has different
   meanings and contents for internal and external purposes: maybe the
   "internal" PDG ID list needs to become part of the grid data header, or can
   the metadata be used?

- **Make GridPDFs not read their info or data blocks until an xf value is requested?!**

   Super-laziness!

- **More aggressive memory and CPU optimisation**

   For example avoiding duplication of x,Q knot arrays between flavors... if
   this "1D" effect is really significant.

- **Read zipped/tarred PDFs**

   With standard directory structure internally. Maybe
   https://code.google.com/p/fuse-zip/ or http://sourceforge.net/projects/avf/?
   Most VFSes seem more designed for CLI use than programmatic ZIP access.

- **Speed up interpolation with (opportunistic) GPU and/or threaded interpolation**

   Interpolation of PDFs seems like an ideal use case for PDFs, since it's
   normal to query for all partons in the set at once: if we can load the
   relevant ipol anchors for all flavours onto the GPU then we can maybe get a
   substantial speedup (with Amdahl's Law as the obvious caveat). Good student
   project...

- **Use HDF5 for the data access?**

   David has more info: I've only ever looked at it in a very rudimentary way,
   e.g. playing with PyTables. Sounds good in principle: I prefer a *real world*
   standard to ROOT, anyway ;-) Does it have any string/typed annotation
   mechanism that we could use?

- **Gradient extrapolator**

   Keep extrapolating linearly outside the range.

- **Updated Octave wrapper**

   To come from Phil Ilten

- **Add helper functions for calculating PDF errors on observables**

   Certainly a good thing to provide an example for... maybe it should just be
   provided as an example? One nice thing is that since we now store a clear
   ErrorType metadata entry for each PDF set, working out the appropriate error
   treatment should be easy (I think it's best to not use words like
   "infallible"!)

- ** **

*/
