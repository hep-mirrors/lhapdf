/**
@page todolist Project to-do list


LHAPDF6 TODO list
=================

NOW / FOR BETA 2
----------------

- **MSTW2008 PDF migration (GW)**

   First attempt to use subgrids in anger. Requires extension

- **NNPDF2.3 PDF migration (??)**

   Just the "main" sets for now. More automation of validation required... we
   can't check thousands of plots so need a more compact performance metric.

- **Improve CTEQ6L1 grid efficiency (MR?)**

- **Fortran compatibility**

   James & Karl: test with PYTHIA6, Pythia8 and Herwig++ using CT10nlo & CTEQ6L1
   once ready.

   Map remaining "metadata" functions such as alpha_s, Nf, min/max x and Q2, etc.

- **Add interpolation-from-metadata implementation of AlphaS**

   Specify with AlphaS_Q2s, and AlphaS_Vals metadata arrays. Hope we can use doubled Q2
   values robustly to implement 1D subgrids.

- **Re-introduce set-level Info singletons (AB)**

   Will allow set-level config changes to propagate to all members of the set.
   Need to define the "lock time", for things like ipol/xpol/alphaS.

- **Profile GridPDF (AB)**

   Compare to LHA5 for same-member and multi-set random sampling. Where is the
   limitation. Intend to compare to self once caching added.

- **Provide setAlphaS methods cf. setInterpolator (AB)**

   The setAlphaS method should set the params appropriate for the PDF it's being
   attached to.

- **AlphaS default params**

   Should the param defaults be clearly invalid so that default AlphaS fields and
   throw an AlphaSException if the values are not in a physical range?

- **Treating missing flavours with error vs. return 0 (AB)**

   Provide a switch to distinguish the two responses. Put ID check into
   PDF::xfxQ2 function?

- **Forbid PDF construction from a direct path to the data file? (AB)**

   Rely on dir structure instead? Do PDFs _need_ to have a dir? (Maybe yes.)
   Same set of constructors for PDF (and derivatives) and Info?
   Throw/assert if dir name and file name are inconsistent


FOR BETA 3
----------

- **Improved x -> 1 (and Q -> 0?) evolution (GW,...)**

   Graeme, etc.: x -> 1 extrapolation should be done carefully to ensure that
   all PDFs -> 0 at x = 1.0, (usually) without going negative. This probably
   deserves specialisation beyond generic splines. Graeme will look at what's
   done in the CTEQ code (other than interpolating in x**0.3)

- **Try using boost::function to generically modify the interpolation measures in x, Q (AB)**

- **Cython mapping improvements (AB)**

   Review to make sure that heap allocated PDFs are garbage collected (loop
   repeated pdf = lhapdf.mkPDF(...) and run Massif). More method mappings.

- **Complete and test ODE and analytic alpha_s running (KN,SL,MR,GW)**

   The ODE solver needs serious optimisation, and numerically the results look
   dubious for both the analytic and ODE versions. Compare to HOPPET/QCD-PEGASUS
   evolution... looks like we can't borrow their ODE code without introducing a
   Fortran dependency, which we'd rather avoid. Maybe start with conversion to
   C++ of this: https://mstwpdf.hepforge.org/code/alphaS.f

- **Profile AlphaS_ODE**

- **Printing out banner info... needed by code that greps for it :-/**

   e.g. ATLAS' Generate_trf.py. Implement the Fortran getdescription_() and
   require it to be explicitly called? Or automatically call it from the Fortran
   interface only.

- **Separate the x and Q2 inter/extrapolation?**

   Allow mix & match combinations. Would this simplify the code since the
   1D interpolation methods are very simple and the 2D is built from them?


FOR STABLE 6.0.0 RELEASE
------------------------

- **Write-up**

   Target at EPJC Tools or CPC?

- **Versioning scheme for PDF data**

   In metadata and tarball filenames?


AS AND WHEN
-----------

- **Support photon structure functions**

   Need to make use of the P2 and IP2 params. No idea how to even start here...

- **Support nuclear corrections**

   Have to be applyable to all nucleon PDFs, regardless of implementation:
   probably nuclear PDFs will inherit from PDF (since they are PDFs) and
   _contain_ a nucleon PDF whose values will be modified before returning.

- **Allow use of valence/sea etc. decompostions**

   GridPDF may be inherited from to allow the returned values to be built from
   separate interpolations of component PDFs such as interpolated valence, sea,
   or difference PDFs that are combined to make the physical ones. The PDG ID
   code range for "generator specific" applications may be used, but we'll need
   to bear in mind that this will mean that the flavor ID list has different
   meanings and contents for internal and external purposes: maybe the
   "internal" PDG ID list needs to become part of the grid data header, or can
   the metadata be used?

- **Make GridPDFs not read their data block until an xf value is requested?!**

   Super-laziness!

- **More aggressive memory and CPU optimisation**

   For example avoiding duplication of x,Q knot arrays between flavors... if
   this "1D" effect is really significant.

- **Read zipped/tarred PDFs**

   With standard directory structure internally. Maybe
   https://code.google.com/p/fuse-zip/ or http://sourceforge.net/projects/avf/?
   Most VFSes seem more designed for CLI use than programmatic ZIP access.

- **Speed up interpolation with (opportunistic) GPU and/or threaded interpolation**

   Interpolation of PDFs seems like an ideal use case for PDFs, since it's
   normal to query for all partons in the set at once: if we can load the
   relevant ipol anchors for all flavours onto the GPU then we can maybe get a
   substantial speedup (with Amdahl's Law as the obvious caveat). Good student
   project...

- **Use HDF5 for the data access?**

   David has more info: I've only ever looked at it in a very rudimentary way,
   e.g. playing with PyTables. Sounds good in principle: I prefer a *real world*
   standard to ROOT, anyway ;-) Does it have any string/typed annotation
   mechanism that we could use?

- **Updated Octave wrapper**

   To come from Phil Ilten

- **Use Autoconf's more robust FC_* Fortran function name macros**

   This would require testing for a Fortran compiler, which we would rather
   not do... but so do tests for Fortran array pointer handling, etc. Test for
   the Fortran compiler unless told not to build LHAGLUE?

- **Add helper functions for calculating PDF errors on observables**

   Certainly a good thing to provide an example for... maybe it should just be
   provided as an example? One nice thing is that since we now store a clear
   ErrorType metadata entry for each PDF set, working out the appropriate error
   treatment should be easy (I think it's best to not use words like
   "infallible"!)

- **Support the new yaml-cpp API... *and* the old one?**

   Would be better to only support one API in HEP... i.e. we can move when Rivet
   does. Getting rid of `yaml-cpp` doesn't seem a good option.

*/
