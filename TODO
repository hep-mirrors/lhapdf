/**
@page todolist Project to-do list


LHAPDF6 TODO list
=================

NOW
---

- **Migrate CTEQ6L1 and CT10 PDFs to new format and validate (SL,MR,DM,AB)**

   AB: I've made CT10 work with a bit of updating of the migration/creategrids
   script. No attempt at validation other than eyeballing in
   gnuplot. pdfsets.index will need to be populated for each set. Metadata will
   need to be set manually, I think (?).

- **Validation system and plotting (SL,MR,DM,BP)**

   Don't try to link both LHAPDFs simultaneously. Generate a big x,Q sample
   point list, then separately dump out xf(x) values into separate files with
   old and new LHAPDF, and finally compare the files line-by-line, with
   pulls/ratios to the "old" LHAPDF as the reference.
   Advice from Graeme/HOPPET is to scan on lines in x and Q2 (with one of the
   pair fixed) rather than to compare randomly sampled points.

- **Fix bicubic interpolation to treat low and high edge cases more carefully (MR,AB)**

   AB: I think I fixed a bug where interpolation in the last "gap" between knots
   did not work, by explicitly returning the n-1'th knot in that edge case. Not
   convinced it was the 100% best way to do it, though: maybe the interpolators
   should have to be more careful?

   Cubic x interpolation should receive the same careful treatment as Q2
   interpolation does: some refactoring should happen to make the same function
   treat both directions.

- **Treat x -> 1 extrapolation properly (GW,AB,MR,...)**

   PDFs must all interpolate to 0 at x=1.0, (usually) without going negative: this
   deserves specialisation beyond generic splines.

   I think there is a good case here for using specialist x and Q2 ipol/xpol
   algorithms... and specifying the x and Q2 parameterisations separately?

   The simplest/quickest solution right now is always to include x = 1 in the
   grids... a bit wasteful, but simpler and (probably) a relatively small
   performance penalty? But we can do better in the long run.

- **Add PDFLIB-style xfx etc. functions, and the non-*m LHAPDF5 Fortran subroutines (JF,KN,BP)**

   Both should just use nset = 0 all the time, I think. getnset_ and getnmem_
   also need to be provided.

   Fortran array pointer passing (and symbol name mangling, and string length
   extra args) schemes to be established using the autoconf `FC_FUNC`
   etc. macros to test the Fortran compiler -- but *only* if the
   `ENABLE_LHAGLUE` conditional is active, i.e. don't test the Fortran compiler
   if it isn't going to be used.

- **Test LHAGLUE with PYTHIA6 and Pythia8 (JF,KN,BP)**

   PY6 will probably need some fiddling to return the array with the expected
   6-element origin offset. pdfsets.index will need to be populated for each set.


FOR BETA 1
----------

- **Add extra flavors line to grid format (AB)**

   Anticipating demand for use of composite PDF parameterisations in future.

- **Change "config" -> "settings"?**

- **Re-introduce set-level Info singletons**

   Will allow set-level configs to propagate to all members.
   Define the "lock time", for things like ipol/xpol/alphaS.


FOR BETA 2
----------

- **Improve the DESIGN document's coherence (AB)**

- **Add interpolation-from-metadata implementation of AlphaS**

   Specify with AlphaS_Q2s, and AlphaS_Vals metadata arrays. Hope we can use doubled Q2
   values robustly to implement 1D subgrids.

- **Fix and test ODE and analytic alpha_s running (KN,SL,MR,GW)**

   The ODE solver needs serious optimisation, and numerically the results look
   dubious for both the analytic and ODE versions. Compare to HOPPET/QCD-PEGASUS
   evolution... looks like we can't borrow their ODE code without introducing a
   Fortran dependency, which we'd rather avoid. Maybe start with conversion to
   C++ of this: https://mstwpdf.hepforge.org/code/alphaS.f

- **Profile GridPDF and AlphaS_ODE**

- **Provide setAlphaS methods cf. setInterpolator (AB)**

   The setAlphaS method should set the params appropriate for the PDF it's being
   attached to.

- **Treating missing flavours with error vs. return 0 (AB)**

   Provide a switch to distinguish the two responses. Put ID check into
   PDF::xfxQ2 function?

- **Forbid PDF construction from a direct path to the data file? (AB)**

   Rely on dir structure instead? Do PDFs _need_ to have a dir? (Maybe yes.)
   Same set of constructors for PDF (and derivatives) and Info?
   Throw/assert if dir name and file name are inconsistent

- **AlphaS default params**

   Should the param defaults be clearly invalid so that default AlphaS fields and
   throw an AlphaSException if the values are not in a physical range?

- **Updated lhapdf-getdata, downloading PDFs as tarballs**

- **Printing out banner info... needed by code that greps for it :-/**

   e.g. ATLAS' Generate_trf.py. Provide a helper function? It shouldn't be
   fundamentally built-in that we have to maintain the old banner style!

- **Metadata standards for accessing special member numbers.**

   e.g. a PosDefMemberID metadata key at set level.

- **Python interface**

   For access to standard functionality but not pluggable in the sense that a
   Python interpolator class cannot be passed to a wrapped PDF object: so hide
   the non-factory-based functions.


FOR STABLE 6.0.0 RELEASE
------------------------

- **Write-up**

   Target at EPJC Tools, cf. Rivet?

- **Versioning scheme for PDF data**

   In metadata and tarball filenames.

- **Provide a way to find the number of members in a PDF set**

   Or just iterate over ints until an Exception is thrown? We should be able to
   find out not just how many members are available but which numbers, so that
   they do not have to be consecutive (modulo the restriction from the LHAPDF ID
   indexing ranges). Determine by counting member data files in the PDF set
   directory (remember that the info file may not be present).


AS AND WHEN
-----------

- **Add more metadata methods to PDF and PDFGrid as needed**

- **Allow use of valence/sea etc. decompostions**

   GridPDF may be inherited from to allow the returned values to be built from
   separate interpolations of component PDFs such as interpolated valence, sea,
   or difference PDFs that are combined to make the physical ones. The PDG ID
   code range for "generator specific" applications may be used, but we'll need
   to bear in mind that this will mean that the flavor ID list has different
   meanings and contents for internal and external purposes: maybe the
   "internal" PDG ID list needs to become part of the grid data header, or can
   the metadata be used?

- **Make GridPDFs not read their data block until an xf value is requested?!**

   Super-laziness!

- **More aggressive memory and CPU optimisation**

   For example avoiding duplication of x,Q knot arrays between flavors... if
   this "1D" effect is really significant.

- **Read zipped/tarred PDFs**

   With standard directory structure internally.

- **Separate the x and Q2 inter/extrapolation?**

   Allow mix & match combinations. Would this simplify the code since the
   1D interpolation methods are very simple and the 2D is built from them?

- **Updated Octave wrapper**

   To come from Phil Ilten

- **Use Autoconf's more robust FC_* Fortran function name macros**

   This would require testing for a Fortran compiler, which we would rather
   not do... but so do tests for Fortran array pointer handling, etc. Test for
   the Fortran compiler unless told not to build LHAGLUE?

- **Add helper functions for calculating PDF errors on observables**

   Certainly a good thing to provide an example for... maybe it should just be
   provided as an example? One nice thing is that since we now store a clear
   ErrorType metadata entry for each PDF set, working out the appropriate error
   treatment should be easy (I think it's best to not use words like
   "infallible"!)

- **Support the new yaml-cpp API... *and* the old one?**

   Or get rid of `yaml-cpp`? We don't want it to be a source of problems, but
   best not to reinvent an existing wheel unless forced to do so...

*/
