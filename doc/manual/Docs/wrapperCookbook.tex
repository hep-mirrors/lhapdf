Wrappers are defined based upon evolution names. If you are trying to load
up a specific PDF then grab your file and look a few lines down until you
find a line "Evolution:", the second line underneath this contains the name
of your evolution routine. If we take cteq6mE.LHgrid as an example then 
we find the evolution name to be 'CTEQ6grid'.

This evolution name defines a few things, according to a standard. Firstly
is the name of the static object that will be loaded by LHAPDF. Calling
the evolution ``evoName'' from here on in, we find the library file to be
called:

\begin{verbatim}
    "libLhapdfWrap" + evoName + ".so"
\end{verbatim}

This static object needs to contain some functions. All the wrappers are
fortran, and LHAPDF should take care of the name mangling, so instead of
dealing with the exact symbols we'll talk about the fortran functions.
A lot of the fortran wrappers will already contain functions with quite
similar names or prototypes to the ones we define below, but if they do not
conform exactly then LHAPDF will not find them. The following functions must
be present in ALL wrappers.

\begin{description}
  \item[ evoName + ``init'' ] \hfill

    \begin{itemize}
      \item Example - evlcteqinit
      \item Description - The initialisation routine for each evolution 
            routine.
      \item Arguments - (int* nset, int* evolveOrder, double* Q2fit)
      \item Notes - The value of nset is always 1.
    \end{itemize}

 \item[  evoName + ``pdf'' ] \hfill

    \begin{itemize}
      \item Description - This initialises the requested PDF.
      \item Arguments - (int* nset)
      \item Notes - The value of nset is always 1, as LHAPDF deals with 
            the data.
    \end{itemize}
      
  \item[ evoName + ``evolve'' ] \hfill

    \begin{itemize}
      \item Description - This takes a value of x and Q and returns the 
            values of xfx in the pdf argument
      \item Arguments - (double* x, double* Q, double* pdf, 
            [double* photon])
      \item Notes - The pdf pointer must point to a freely editable block 
            in memory of size sizeof(double)*13. The photon argument only 
            applies for pdfs that also return a value for the photon
    \end{itemize}

  \item[ evoName + ``alfa'' ] \hfill

    \begin{itemize}
      \item Description - This returns the value of AlphaS depending on 
            the value of Q.
      \item Arguments - (double* AlphaS, double* Q);
      \item Notes - The AlphaS argument is the return argument, Q is the 
            independant variable.
    \end{itemize}

\end{description}

The following function is specific to Evolution PDFs:
    
\begin{description}
  \item[ evoName + ``read'' ] \hfill

    \begin{itemize}
      \item Description - This reads in evolution routine specific data.
      \item Arguments - (int* nset)
      \item Notes - The value of nset is always 1.
    \end{itemize}
\end{description}

I assume that these will be staticly linked C++ functions, and so they will 
need to be exposed as correctly name mangled fortran functions - go find 
FC\_FUNC. However, in order to get the correct name mangling, and not fall 
victim to C++ name mangling these functions should be declared in an extern
C block, i.e.:

\begin{verbatim}
  extern "C"
  {
    void evlcteqinit_(int* nset, int* evolveOrder, double* Q2fit){}
    //etc
  }
\end{verbatim}

So far we have covered the wrapping standard, but not looked at the 
specifics of memory allocation for Grid PDFs. This is handled by the
wrappers as the amount of memory allocation differs between evolution 
routines, however for a single array it is very simple and you can simply
use the ``Database'' class without having to edit it.

The setup is this - when reading in the data (with the ``read'' routine) we
need to allocate an appropriate amount (with an ``alloc'' routine). What's
LHAPDF needs a way to push the correct data to the routine when requested
(with a ``putdata'' routine) and this requires using Fortran pointers (so we
need a Fortran ``point'' routine). Let's go ahead and start how with editing
the ``read'' routine with all of this in mind.

Firstly we need to deal with the function prototype - it needs one more
argument - the member that we want to load, it should look like this:

evoName + "read\_":

  \begin{itemize}
    \item Arguments = (int* nset, int* member)
    \item Notes - The value of nset is always 1. The member argument 
          dictates which member should be read into memory.
  \end{itemize}

Both the C++ wrapping and the fortran should have this member argument (the
arguments given above are in C, but I'll assume you're competent in 
Fortran).

Secondly we need to find how much data we have to allocate, so the job
(which can't be fully directed) is basically to find the biggest array
around. This will be at the top of the subroutine. In the case of wraphkn.f
this was actually 4 arrays each of the same size, all will need to be
managed - PDFG BXG CXG DXG. These each are designed to hold up to nhess
members (I believe that's because members are also called hessian sets).
But we want to do the managing and only create one member, so we better
find that nhess variable and set it to 0! In another PDF they may well use
a different variable name, but the principle is the same.

LHAPDF manages this data by the use of Fortran 90 pointers. The types of 
these arrays should be replaced by pointers of the same data type and
dimension. Then a target array of the original size needs to be declared.

For example:

\begin{verbatim}
  double precision BXG(NX, NQ, ND, 0:nhess)
\end{verbatim}

becomes:

\begin{verbatim}
  double precision, pointer :: BXG(:,:,:,:)
  double precision, target  :: PointToMe(NX, NQ, ND, 0:nhess)
\end{verbatim}

A very short routine/entry then needs to be created that takes the argument 
PointToMe and points BXG towards it. E.g.:

    \begin{verbatim}
      entry evonamePoint(PointToMe)
      BXG => PointToMe
      return
    \end{verbatim}

This may need to be more compliated if you have multiple arrays, but it
should still be simple. This routine is later called from within two (C) 
functions evonamealloc and evonameputdata. This then brings me onto the 
storage of the data, i.e. where "PointToMe" is declared. Firstly a call to 
an allocation routine should be made at the top of the read function. This 
routine takes the size (in units of double) of the block of data that needs 
to be allocated. A second argument that it takes, also describes the shape
of the array in some way. You need to calculate the pointer difference
between the (1,1,1,1) element and the beginning of the block. Please
remember that fortran uses row major array ordering! An example of the
call is below:

\begin{verbatim}
  call hkngridalloc(NX * NQ * ND *(1+nhess), NX * NQ * ND)
\end{verbatim}

This subroutine is provided by the C++ side of things, and so we go on to
talking about the specifics of the C++ wrapper. It is best to take an 
example of a real wrapper, if the below description is confusing. Please
note that you may have already written some of the C++ wrapper in order to
simply get the fortran functions to have names that fit with the standard.
This should simply be an extension. The below example is from wrapHKNgrid.C

\begin{verbatim}
#include "Tools/Database.H"
using namespace LHAPDFTOOLS;

void  LhapdfSaveDB(Database* db);

class HKNgridTable : public Database 
{
  public: 
    double *m_PDFG, *m_BXG, *m_CXG, *m_DXG;
    size_t m_pointerOffset;

  public:
    HKNgridTable( size_t tableSize, size_t pointerOffset ) : Database()
    {
      m_tableSize = tableSize;

      m_PDFG = (double*)malloc(m_tableSize);
      m_BXG  = (double*)malloc(m_tableSize);
      m_CXG  = (double*)malloc(m_tableSize);
      m_DXG  = (double*)malloc(m_tableSize);

      m_pointerOffset = pointerOffset;
    }

    ~HKNgridTable()
    {
      if (m_PDFG != NULL) free(m_PDFG);
      if (m_BXG  != NULL) free(m_BXG);
      if (m_CXG  != NULL) free(m_CXG);
      if (m_DXG  != NULL) free(m_DXG);
    }
};

extern "C" 
{
  void hkngridpoint_(const int& pointerID, double* pointer);

  void hkngridputdata_(Database* db)
  {
    HKNGridTable* table = dynamic_cast<HKNGridTable*>(db);
    double* PDFG = table->m_PDFG;
    double* BXG  = table->m_BXG;
    double* CXG  = table->m_CXG;
    double* DXG  = table->m_DXG;

    #if F_ARRAY_REZERO == 1
      PDFG += table -> m_pointerOffset;
      BXG  += table -> m_pointerOffset;
      CXG  += table -> m_pointerOffset;
      DXG  += table -> m_pointerOffset;
    #endif
    
    hkngridpoint_(0,PDFG);
    hkngridpoint_(1,BXG );
    hkngridpoint_(2,CXG );
    hkngridpoint_(3,DXG );
  }

  void hkngridalloc_(int* size, int* pointOffset)
  {
    size_t memSize = (*size)*sizeof(double);
    size_t memPointOffset = (*pointOffset);

    HKNGridTable* table = new HKNGridTable(memSize, memPointOffset);
    LhapdfSaveDB(table);

    hkngridputdata_(table);
  }

}
\end{verbatim}

The LhapdfSaveDB function saves the pointer to the table in LHAPDF and will
be found when linking. The hkngridpoint\_ function is previously mentioned, 
defined in the fortran. The HKNGridTabld class inherits from public 
Database, which by default has a void* m\_tableData and size\_t 
m\_pointOffset, for ease if the evolution routine only has a single data 
array, otherwise the mallocing and freeing of the data will have to be done
by you (as in the above example). The hkngridalloc\_ routine simply creates
the table and calls hkngridputdata. The putdata routine is called by LHAPDF 
every time it wants to use this member. As it is only repointing and not 
copying any data this is a fast process. This should be all you need to 
create a working grid database and evolution routine. Examples can simply 
be the currently working grid  PDFs, the most simple of which is probably 
wrapCTEQ6grid and the most complicated of which (and which demonstrates 
the mallocing and freeing of the required data) is wrapMRST2006grid. 
Please note that in these examples there are a few more functions that 
simply wrap the provided fortran into a way that suits LHAPDF 6.
  
The final thing to talk about is the idea of member skipping. The Fortran
is probably currently loading into the array as if it's big enough to hold
all of the members, but it's not - it can only hold one! So we first need
to adjust the Read(1,*) lines such that they always only pump into the 0th
member. Usually you'll find a variable like ``n'' that will simply need to
be replaced with the value 0. But the read loop still reads all of the
members. The chose course of action here was to stop the read loop once it
gets to the requested member. So find the loop over that variable ``n'' and
make it finish at whatever you've called the second argument of the read
routine (rewriteMem in all examples).

Now you should have a fully functioning wrapper!
