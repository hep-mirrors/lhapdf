Fortran\_PDF\_Base is the main interface class for the Fortran wrappings,
and currently contains (due to restrictions) the majority of active LHAPDF
code. Most of the "action" takes place in the Initialise function, but
before we can discuss this we have to take a detour into Fortran File IO.

It is an unfortuante consequence of the way that Fortran works that we have
to choose either C's file IO routines, or Fortran's. In order to minimise
the amount of damage that had to be done to each wrapper when converting
them to LHAPDF6, we chose to use Fortran IO routines. This has the
unfortunate disadvantage of tying all of the File IO to something that is
quite archaic. It would be a job of future versions to potentially go
through the wrappers and use C++ IO, as I would imagine that the only IO
takes place in the wrapper, and we have edited them much more than
orginally intended. (Described later)

The Fortran File IO is wrapped up in a Fortran File class. Fortran File IO
has the unfortunate problem of reading the entire line at the same time,
but does put things into the appropriate data types easily. This leads to
some strange looking (to a C developer) functions such as 
``ReadStringAndDoubles'', which reads a string and 2 doubles into the given
arguments. This is simply because a few of the lines in the PDF headers are
exactly that - a string followed by two doubles. However, C requires such
specialisation. For more explicit details, look at FortranIO.H and
fortranIO.f90.

We now move on to discuss the Fortran\_PDF\_Base itself. As previously
stated this class is the heart of the rewrite, and undertakes the process
of dynamically linking the required functions for each PDFset. The other
main part of the rewrite is to do with Interpolation (grid) PDFs and their
allocation of data, but this is discussed later.

The bulk of the initialise function is simply grabbing header data and
putting it into appropriate structures/classes. This is relatively
uninteresting (and unimportant) so I shall focus predominantly on the
dynamic linking. The structure of the Fortran\_PDF\_Base allows it to 
provide 3 of the 4 necessary virtual functions for a PDF\_Base: Evolve,
EvolveAlpha and Initialise. The Evolve and EvolveAlpha simply take the
dynamically linked symbols and run them with the correct arguments. This is
accomplished by simply using a function pointer - this has the great
advantage of not requiring the lookup table as in the old LHAPDF, which
provides a speed increase.

The dynamic linking works using the dlopen library, and it's three main
functions - dlopen, dlsym and dlclose. The dlopen function takes a string,
naming the .so and returns a handle. Internally it is allocating all the
memory for the code, and it is important to note that any functions called
from within this library allocate their memory in a way that is managed by
the dynamic linking. That is, if (as I did) you store a pointer to this
memory outside of the library, then a call to dlclose will free it and your
pointer becomes invalid.

The Fortran\_PDF\_Base goes looking for it's functions based upon the
``Evolution Name'', this is given as the line underneath ``Evolution:'' in
the PDF header. (Hence any PDFs without headers will always struggle...).
The specific functions it goes looking for (for a given evoName) are:

\begin{itemize}
  \item evoName + "read"
  \item evoName + "init"
  \item evoName + "pdf"
  \item evoName + "evolve" 
\end{itemize}

These are names defined in a fortran scheme, so they will undergo some sort
of fortran name mangling at compile time. However the current implementation
only supports a name mangling system of lower casing the string and
appending with a single underscore, for example "evlcteqinit\_". This should
be rectified in a future version.

%FIXME - include technical information of what these functions do
