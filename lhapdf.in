#! /usr/bin/env python
## @configure_input@

# Load settings from installation on PYTHONPATH, otherwise use configure
try:
    import lhapdf
    __version__ = lhapdf.__version__
    configured_datadir = lhapdf.paths()[0]
except ImportError:
    __version__ = '@PACKAGE_VERSION@'
    configured_datadir = '@datarootdir@'.replace('${prefix}', '@prefix@')

major_version = '.'.join(__version__.split('.')[:2])
urlbase = 'http://www.hepforge.org/archive/lhapdf/pdfsets/' + major_version + '/'
index_filename = 'pdfsets.index'


import os, sys, math, optparse, textwrap, logging, csv, urllib2, tarfile, fnmatch
import yaml

class Subcommand(object):
    """A subcommand of a root command-line application that may be
    invoked by a SubcommandOptionParser.
    """
    def __init__(self, name, help='', aliases=(), **kwargs):
        """Creates a new subcommand. name is the primary way to invoke
        the subcommand; aliases are alternate names. parser is an
        OptionParser responsible for parsing the subcommand's options.
        help is a short description of the command. If no parser is
        given, it defaults to a new, empty OptionParser.
        """
        self.name = name
        kwargs['add_help_option'] = kwargs.get('add_help_option', False)
        self.parser = optparse.OptionParser(**kwargs)
        if not kwargs['add_help_option']:
            self.parser.add_option('-h', '--help', action='help', help=optparse.SUPPRESS_HELP)
        self.aliases = aliases
        self.help = help
        
class SubcommandsOptionParser(optparse.OptionParser):
    """A variant of OptionParser that parses subcommands and their arguments."""
    
    # A singleton command used to give help on other subcommands.
    _HelpSubcommand = Subcommand('help',
        help='give detailed help on a specific sub-command',
        aliases=('?',))
    
    def __init__(self, *args, **kwargs):
        """Create a new subcommand-aware option parser. All of the
        options to OptionParser.__init__ are supported in addition
        to subcommands, a sequence of Subcommand objects.
        """
        # The subcommand array, with the help command included.
        self.subcommands = list(kwargs.pop('subcommands', []))
        self.subcommands.append(self._HelpSubcommand)
        
        # A more helpful default usage.
        if 'usage' not in kwargs:
            kwargs['usage'] = """
  %prog COMMAND [ARGS...]
  %prog help COMMAND"""
        
        # Super constructor.
        optparse.OptionParser.__init__(self, *args, **kwargs)
        
        # Adjust the help-visible name of each subcommand.
        for subcommand in self.subcommands:
            subcommand.parser.prog = '%s %s' % \
                    (self.get_prog_name(), subcommand.name)
        
        # Our root parser needs to stop on the first unrecognized argument.  
        self.disable_interspersed_args()
    
    def add_subcommand(self, cmd):
        """Adds a Subcommand object to the parser's list of commands."""
        self.subcommands.append(cmd)
    
    # Add the list of subcommands to the help message.
    def format_help(self, formatter=None):
        # Get the original help message, to which we will append.
        out = optparse.OptionParser.format_help(self, formatter)
        if formatter is None:
            formatter = self.formatter
        
        # Subcommands header.
        result = ["\n"]
        result.append(formatter.format_heading('Commands'))
        formatter.indent()
        
        # Generate the display names (including aliases).
        # Also determine the help position.
        disp_names = []
        help_position = 0
        for subcommand in self.subcommands:
            name = subcommand.name
            if subcommand.aliases:
                name += ' (%s)' % ', '.join(subcommand.aliases)
            disp_names.append(name)
                
            # Set the help position based on the max width.
            proposed_help_position = len(name) + formatter.current_indent + 2
            if proposed_help_position <= formatter.max_help_position:
                help_position = max(help_position, proposed_help_position)        
        
        # Add each subcommand to the output.
        for subcommand, name in zip(self.subcommands, disp_names):
            # Lifted directly from optparse.py.
            name_width = help_position - formatter.current_indent - 2
            if len(name) > name_width:
                name = "%*s%s\n" % (formatter.current_indent, "", name)
                indent_first = help_position
            else:
                name = "%*s%-*s  " % (formatter.current_indent, "",
                                      name_width, name)
                indent_first = 0
            result.append(name)
            help_width = formatter.width - help_position
            help_lines = textwrap.wrap(subcommand.help, help_width)
            result.append("%*s%s\n" % (indent_first, "", help_lines[0]))
            result.extend(["%*s%s\n" % (help_position, "", line)
                           for line in help_lines[1:]])
        formatter.dedent()
        
        # Concatenate the original help message with the subcommand
        # list.
        return out + "".join(result)
    
    def _subcommand_for_name(self, name):
        """Return the subcommand in self.subcommands matching the
        given name. The name may either be the name of a subcommand or
        an alias. If no subcommand matches, returns None.
        """
        for subcommand in self.subcommands:
            if name == subcommand.name or \
               name in subcommand.aliases:
                return subcommand
        return None
    
    def parse_args(self, a=None, v=None):
        """Like OptionParser.parse_args, but returns these four items:
        - options: the options passed to the root parser
        - subcommand: the Subcommand object that was invoked
        - suboptions: the options passed to the subcommand parser
        - subargs: the positional arguments passed to the subcommand
        """  
        options, args = optparse.OptionParser.parse_args(self, a, v)
        
        if not args:
            # No command given.
            self.print_help()
            self.exit()
        else:
            cmdname = args.pop(0)
            subcommand = self._subcommand_for_name(cmdname)
            if not subcommand:
                self.error('unknown command ' + cmdname)
        
        suboptions, subargs = subcommand.parser.parse_args(args)
 
        if subcommand is self._HelpSubcommand:
            if subargs:
                # particular
                cmdname = subargs[0]
                helpcommand = self._subcommand_for_name(cmdname)
                helpcommand.parser.print_help()
                self.exit()
            else:
                # general
                self.print_help()
                self.exit()
        
        return options, subcommand, suboptions, subargs
 
class PdfSet(object):
    """Stores PDF metadata: name, version, ID code."""
    def __init__(self, name, version, id_code):
        self.name    = name
        self.version = version
        self.id_code = id_code
    def __eq__(self, other):
        if isinstance(other, PdfSet):
            return self.name == other.name
        else:
            return self.name == other
    def __ne__(self, other):
        return not self == other
    def __repr__(self):
        return self.name


def get_reference_list(filepath):
    """Reads reference file and returns list of PDF info.

    The reference file is space-delimited, with columns:
    id_code version name
    """
    database = []
    try:
        csv_file = open(filepath, 'rb')
        logging.debug('Reading %s' % filepath)
        reader = csv.reader(csv_file, delimiter=' ', skipinitialspace=True, strict=True)
        for row in reader:
            id_code, version, name = int(row[0]), int(row[1]), str(row[2])
            database.append(PdfSet(name, version, id_code))
    except IOError:
        logging.error('Could not open %s' % filepath)
    except (ValueError, csv.Error):
        logging.error('Corrupted file on line %d: %s' % (reader.line_num, filepath))
        csv_file.close()
        database = []
    else:
        csv_file.close()
    return database


def get_installed_list(path):
    """Returns list of PDF info for PDF sets installed in 'path'.

    The path to each YAML file is assumed to be:
    path/pdf_name/pdf_name.info
    """
    if not os.path.isdir(path):
        logging.error('Unable to find directory %s' % path)
        return []

    database = []
    for subdir in os.listdir(path):
        metadata_filepath = os.path.join(path, subdir, subdir + os.extsep + 'info')
        if os.path.isfile(metadata_filepath):
            try:
                metadata_file = open(metadata_filepath, 'rb')
                logging.debug('Reading %s' % metadata_filepath)
                metadata = yaml.load(metadata_file)
                name = subdir
                version = int(metadata['DataVersion'])
                database.append(PdfSet(name, version, 0))
            except IOError:
                logging.error('Could not open %s' % metadata_filepath)
            except ValueError:
                logging.error('Corrupted file %s' % metadata_filepath)
                metadata_file.close()
            else:
                metadata_file.close()
    return database


def download_file(url, dest_dir, dryrun=False):
    """Download a file from url to destination directory."""
    if not os.path.isdir(os.path.abspath(dest_dir)):
        logging.info('Creating directory %s' % dest_dir)
        os.makedirs(dest_dir)

    dest_filepath = os.path.join(dest_dir, os.path.basename(url))

    try:
        u = urllib2.urlopen(url)
        file_size = int(u.info().getheaders('Content-Length')[0])
    except urllib2.URLError as e:
        logging.error('Unable to download %s' % url)
        logging.debug('Reason: ', e.reason)
        return False

    logging.debug('Downloading from %s' % url)
    logging.debug('Downloading to %s' % dest_filepath)
    if dryrun:
        logging.info('%s [%s]' % (os.path.basename(url), convertBytes(file_size)))
        return False

    try:
        dest_file = open(dest_filepath, 'wb')
        file_size_dl = 0
        buffer_size  = 8192
        while True:
            buffer = u.read(buffer_size)
            if not buffer: break

            file_size_dl += len(buffer)
            dest_file.write(buffer)

            status  = chr(13) + '%s: ' % os.path.basename(url)
            status += r'%s [%3.1f%%]' % (convertBytes(file_size_dl).rjust(10), file_size_dl * 100. / file_size)
            print status,
    except IOError:
        logging.error('Could not write to %s' % dest_filepath)
    except urllib2.URLError as e:
        logging.error('Error during download: ', e.reason)
        dest_file.close()
    except KeyboardInterrupt:
        logging.error('Download halted by user')
        dest_file.close()
    else:
        dest_file.close()
    finally:
        print
        return False
    return True


def convertBytes(size, nDecimalPoints=1):
    units = ('B', 'KB', 'MB', 'GB')
    i = int(math.floor(math.log(size, 1024)))
    p = math.pow(1024, i)
    s = round(size/p, nDecimalPoints)
    if (s > 0):
        return '%s %s' % (s, units[i])
    else:
        return '0 B'


if __name__ == '__main__':
    #######################
    #  Setup subcommands  #
    #######################
    update_cmd = Subcommand('update',
        help='update list of available PDF sets')

    list_cmd = Subcommand('list', aliases=('ls',),
        help='list installed/available PDF sets')
    list_cmd.parser.add_option('--installed', action='store_true',
        help='show installed PDF sets')
    list_cmd.parser.add_option('--outdated', action='store_true',
        help='show installed, but outdated, PDF sets')
    list_cmd.parser.add_option('--codes', action='store_true',
        help='show ID codes')

    install_cmd = Subcommand('install', usage='%prog PDF...', aliases=('get',),
        help='install PDF sets')
    install_cmd.parser.add_option('--dryrun', action='store_true',
        help='Do not download sets')
    install_cmd.parser.add_option('--upgrade', action='store_true',
        help='Force reinstall (used to upgrade)')

    #####################################
    #  Setup global parser and options  #
    #####################################
    parser = SubcommandsOptionParser(
        description = 'LHAPDF is an interface to parton distribution functions. This program is intended for browsing and installing the PDFs.',
        version     = __version__,
        subcommands = (update_cmd, list_cmd, install_cmd)
    )
    parser.add_option('-q', '--quiet', help='Suppress normal messages',
        dest='LOGLEVEL', action='store_const', const=logging.WARNING, default=logging.INFO)
    parser.add_option('-v', '--verbose', help='Output debug messages',
        dest='LOGLEVEL', action='store_const', const=logging.DEBUG, default=logging.INFO)
    parser.add_option('--listdir', default=configured_datadir,
        help='PDF list directory [default: %default]')
    parser.add_option('--pdfdir', default=configured_datadir,
        help='PDF sets directory [default: %default]')

    ##############################
    #  Parse command-line input  #
    ##############################
    options, subcommand, suboptions, subargs = parser.parse_args()
    logging.basicConfig(level=options.LOGLEVEL, format='%(levelname)s: %(message)s')
    if subcommand is list_cmd:
        if suboptions.installed and suboptions.outdated:
            subcommand.parser.error("Options '--installed' and '--outdated' are mutually exclusive")


    if subcommand is update_cmd:
        download_file(urlbase + index_filename, options.listdir)
        sys.exit(0)

    # Convert to dict for easy lookup
    reference = {pdf.name: pdf for pdf in get_reference_list(os.path.join(options.listdir, index_filename))}
    installed = {pdf.name: pdf for pdf in get_installed_list(options.pdfdir)}

    # Check installation status of all PDFs
    for pdf in reference.keys():
        if pdf in installed:
            reference[pdf].installed = True
            if installed[pdf].version < reference[pdf].version:
                reference[pdf].oudated = True

    # Unix-style pattern matching of arguments
    requested_pdfs = []
    for pattern in subargs:
        requested_pdfs += fnmatch.filter(reference.keys(), pattern)

    if subcommand is list_cmd:
        # No patterns given => use all PDFs
        if len(subargs) == 0:
            requested_pdfs = reference.keys()

        if suboptions.installed:
            displayed_pdfs = [pdf for pdf in requested_pdfs if hasattr(reference[pdf], 'installed')]
        elif suboptions.outdated:
            displayed_pdfs = [pdf for pdf in requested_pdfs if hasattr(reference[pdf], 'outdated')]
        else:
            displayed_pdfs = requested_pdfs

        for pdf in sorted(displayed_pdfs):
            if suboptions.codes:
                print '%d %s' % (reference[pdf].id_code, pdf)
            else:
                print pdf
        sys.exit(0)


    if subcommand is install_cmd:
        for pdf in sorted(requested_pdfs):
            if pdf not in reference:
                logging.warn('PDF not recognised: %s' % pdf)
                continue
            if pdf in installed:
                logging.warn('PDF already installed: %s (use --upgrade to force install)' % pdf)
                if not suboptions.upgrade:
                    continue

            tar_filename = pdf + '.tar.gz'
            if download_file(urlbase + tar_filename, options.pdfdir, dryrun=suboptions.dryrun):
                try:
                    tar_file = tarfile.open(os.path.join(options.pdfdir, tar_filename), 'r:gz')
                    tar_file.extractall(options.pdfdir)
                    tar_file.close()
                except:
                    logging.error('Unable to extract %s' % tar_filename)



